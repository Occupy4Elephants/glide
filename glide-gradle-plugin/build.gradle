plugins {
    id 'maven-publish'
    id 'java-gradle-plugin'
    id 'net.researchgate.release' version '2.3.5'
    id 'com.jfrog.bintray' version '1.6'
}

// Hackery for gradle test kit:
// Write the plugin's classpath to a file to share with the tests
task createClasspathManifest {
    def outputDir = file("$buildDir/$name")

    inputs.files sourceSets.main.runtimeClasspath
    outputs.dir outputDir

    doLast {
        outputDir.mkdirs()
        file("$outputDir/plugin-classpath.txt").text = sourceSets.main.runtimeClasspath.join("\n")
    }
}


configurations {
    testIntegrationCompile.extendsFrom testCompile
    testIntegrationRuntime.extendsFrom testRuntime

    glideFilters
}

/**
 * If groovy is not excluded in transitive deps, build Fails with:
 * groovy.lang.GroovyRuntimeException: Conflicting module versions.
 * Module [groovy-all is loaded in version 2.3.10 and you are trying to load version 2.4.3
 */
dependencies {
    compile gradleApi()
    compile localGroovy()
    testCompile gradleTestKit()

    compile "org.gradle.api.plugins:gradle-gaelyk-plugin:${gaelykGradlePluginVersion}", {
        exclude group: 'io.github.kdabir.directree'
    }

    compile "com.google.appengine:gradle-appengine-plugin:${appengineGradlePluginVersion}"

    compile "io.github.kdabir.directree:directree:${directreeVersion}", {
        exclude group: 'org.codehaus.groovy'
    }

    glideFilters project(":glide-filters")

    testCompile "junit:junit:${junitVersion}"
    testCompile "org.spockframework:spock-core:${spockVersion}", {
        exclude group: 'org.codehaus.groovy'
    }

    // Add the classpath file to the test runtime classpath
    testRuntime files(createClasspathManifest)
}

sourceSets {
    main.groovy.srcDirs = ['src']
    test.groovy.srcDirs = ['test']

    main.resources.srcDirs = ['resources']
    test.resources.srcDirs = ['testResources']

    main.java.srcDirs = test.java.srcDirs = []

    testIntegration {
        groovy {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDirs = ['test-intg']
        }
    }
}

jar {
    manifest {
        attributes(
                "Implementation-Title": "Gradle",
                "Implementation-Version": project.version
        )
    }
}

import org.apache.tools.ant.filters.*

afterEvaluate {
    configure(tasks['processResources']) {
        def versions = project.properties.findAll { k, v -> k.endsWith("Version") && v instanceof String }

        def selfVersion = project.version.toString()
        versions.put("glideGradlePluginVersion", selfVersion)

        if (project.hasProperty("glideFiltersVersion")) {
            versions.put("glideFiltersVersion", project.glideFiltersVersion)

        } else {
            if (selfVersion.endsWith("SNAPSHOT")) {
                logger.quiet "using SNAPSHOT version"
                def filtersProjectVersion = project.configurations.glideFilters.dependencies.first().version.toString()
                versions.put("glideFiltersVersion", filtersProjectVersion)

            } else {
                try {
                    def metadata = new XmlSlurper().parse("https://dl.bintray.com/kdabir/glide/io/github/kdabir/glide/glide-filters/maven-metadata.xml")
                    def latest = metadata.versioning.latest.text()

                    logger.quiet "Following versions are available : ${metadata.versioning.versions.version*.text()}"
                    logger.quiet "Choosing latest : ${latest}"

                    versions.put("glideFiltersVersion", latest)
                } catch (e) {
                    throw new RuntimeException("unable to fetch maven metadata, set Project property 'glideFiltersVersion' explicitly from command line")
                }
            }
        }

//        inputs.properties versions // so that resources are processed on version change
        filter(ReplaceTokens, tokens: versions)
    }
}


task integrationTest(type: Test) {
    dependsOn ":glide-filters:publishToMavenLocal"
    group = "verification"
    description = "runs the integration tests"

    testClassesDir = sourceSets.testIntegration.output.classesDir
    classpath = sourceSets.testIntegration.runtimeClasspath

    testLogging {
        events "failed"
        exceptionFormat "short"
    }

}

publishing {
    publications {
        gradlePlugin(MavenPublication) {
            from components.java
        }
    }
    println configurations.runtime.allDependencies
}

// set bintrayUser & bintrayKey in gradle.properties
bintray {
    user = project.properties.get "bintrayUser"
    key = project.properties.get "bintrayKey"
    publications = ['gradlePlugin']

    def projectName = project.name
    def projectDescription = project.description

    pkg {
        repo = 'glide'
        name = projectName      // somehow project.* doesn't work in this closure
        desc = projectDescription
        licenses = ['MIT']
        vcsUrl = 'https://github.com/kdabir/glide.git'
    }
//    dryRun = true // whether to run this as dry-run, without deploying
}


release {
    tagTemplate = '$name-$version'
}


//afterReleaseBuild.dependsOn clean
//bintrayUpload.mustRunAfter clean
afterReleaseBuild.dependsOn bintrayUpload