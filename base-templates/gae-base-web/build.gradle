// workaround for using project app dir as exploded app dir.
// Important : needs to to execute before gae plugin, so needs to be at top of script
// adds `app` dir as explodableAppDirectory of tasks that depends on exploded app
// tasks like run, upload etc.
project.tasks.whenTaskAdded { task ->
    if (task instanceof com.google.appengine.task.Explodable) {
        // println "----------- added explodable task : ${task.name}"
        task.explodedAppDirectory = project.file("app")
    }
}

apply plugin: 'groovy'
apply plugin: 'war'
apply plugin: 'gaelyk'
apply plugin: 'idea'

appengine {
    disableUpdateCheck = true
    appcfg {
        oauth2 = true
    }
    warDir = file('app') // important for Dev App server to read from app dir
}

// important for the app dir to be complete with lib and classes
appengineExplodeApp {
    setOnlyIf { true }
    explodedAppDirectory = file("app") // may not need it because of hackery on top
}

def GLIDE_BUILD_FILE = "glide.gradle"

if (new File(projectDir, GLIDE_BUILD_FILE).exists()) {
    apply from: GLIDE_BUILD_FILE
}

def templateJavaVersion = 1.7
def templateGroovyVersion = '2.3.6'
def templateGaeVersion = '1.9.8'
def templateGaelykVersion = '2.1.2'
def templateVersion = '0.3.4'
def templateGradleVersion = "2.0"
def templateSitemapVersion = "3.0.1-SNAPSHOT" // 3.0.0 is not working well for mutliple decorators.

sourceCompatibility = templateJavaVersion
targetCompatibility = templateJavaVersion

webAppDirName = "app"
sourceSets {
    main.groovy.srcDir 'src'
    test.groovy.srcDir 'test'
}

// output the compiled classes from src directly to app
// so that we may skip war'ing & exploding the app
sourceSets.main.output.classesDir = 'app/WEB-INF/classes'

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'org.gradle.api.plugins:gradle-gaelyk-plugin:0.6'
    }
}

import static com.google.appengine.task.AbstractTask.*
build.doFirst {
    // TODO feels little hacky, but there is no way around right now !
    def appEngineHomeEnvVariable = System.getenv(APPENGINE_HOME_ENV_PROP_KEY)
    def appEngineSdkRoot = System.getProperty(APPENGINE_SDK_ROOT_SYS_PROP_KEY)

    println "using sdk: ${appEngineHomeEnvVariable?:appEngineSdkRoot}"
    new File(projectDir, ".sdk-root").text = appEngineHomeEnvVariable?:appEngineSdkRoot
}

repositories {
    mavenCentral()
    jcenter()
    mavenLocal()
}

dependencies {
    compile 'javax.servlet:servlet-api:2.5'
    compile "org.codehaus.groovy:groovy-all:${templateGroovyVersion}"

    compile "com.google.appengine:appengine-api-1.0-sdk:$templateGaeVersion",
            "com.google.appengine:appengine-api-labs:$templateGaeVersion"
    compile "org.gaelyk:gaelyk:$templateGaelykVersion"
    compile "org.sitemesh:sitemesh:$templateSitemapVersion"


    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
    testCompile 'junit:junit:4.10'
    testCompile "com.google.appengine:appengine-api-stubs:$templateGaeVersion",
            "com.google.appengine:appengine-testing:$templateGaeVersion"

    appengineSdk "com.google.appengine:appengine-java-sdk:$templateGaeVersion"
}

task tempalteVersion << {
    println "$templateVersion"
}

task wrapper(type: Wrapper) {
    gradleVersion = templateGradleVersion
}


//>
// TODO: remove following lines after export
gaelykSynchronizeResources.enabled = false

test {
    doFirst {
        System.out.println "\nTesting Glide Application"
    }

    def ident = '  '

    beforeSuite {
        if (!it.className) return
        System.out.println "${ ident * countParents(it) }$it.name"
    }
    beforeTest {
        System.out.print "${ ident * countParents(it) }$it.name "
    }
    afterTest { descriptor, result ->
        if (result.exception) {
            System.out.println "\u001B[31m" + result.resultType + "\u001B[0m"
            System.out.println( (ident * (countParents(descriptor) + 1)) + result.exception.toString().replace('\n', '\n' +  (ident * (countParents(descriptor) + 1))))
        } else {
            System.out.println "\u001B[32m" + result.resultType + "\u001B[0m"
        }
    }
    afterSuite { descriptor, result ->
        if (descriptor.toString() != 'tests') return
        if (result.failedTestCount > 0) {
            System.out.println ("\n\u001B[31m $result.failedTestCount/$result.testCount TESTS FAILED \u001B[0m\n")
        } else {
            System.out.println ("\n\u001B[32m ALL TESTS PASSSED\u001B[0m\n")
        }
    }
}
test.dependsOn cleanTest


def countParents(testDescriptor) {
    if (!testDescriptor.parent || !testDescriptor.className) return 0
    countParents(testDescriptor.parent) + 1
}
//<
